"run_vertical.vim
function! ExecuteInshellv(command)
     let command = join(map(split(a:command), 'fnameescape(v:val)'))
     let winnr = bufwinnr('^' . command . '$')
     if winnr < 0
         execute 'botright vnew ' . fnameescape(command)
     else
         execute winnr . 'wincmd w'
     endif

     setlocal buftype=nofile bufhidden=wipe noswapfile nowrap number
     silent execute '%! ' . command . ' 2>&1'
     silent! execute 'resize'
     silent! redraw

     autocmd BufUnload <buffer> silent! execute "bwipeout"
     silent! execute 'nnoremap <silent> <buffer> <LocalLeader>r :call <SID>ExecuteInshellv(''' . command . ''')<CR>
 endfunction

 " Define the command with proper completion and argument handling
 command! -complete=shellcmd -nargs=+ EV call ExecuteInshellv(<q-args>)


"cpp_make.vim


 source ~/.vim/run_vertical.vim

 command! -nargs=0 Make call Compile()
 function Compile()
     let main_win_buf = bufwinnr(expand("%:p:t"))

     silent! execute set mp=g++\ -std=c++2c\ -fconcepts\ -D_GLIBCXX_USE_CXX11_ABI=0\ -ggdb\ -lpthread -o\ %<\ %'
     silent! execute 'make'
     silent! execute '15cw'
     silent! execute 'redraw'

     if main_win_buf > 0
         silent execute main_win_buf . 'wincmd w'
     endif
 endfunction

 command! -nargs=? Run call s:RunFunc(<q-args>)
 function! s:RunFunc(args) abort
     let runCmd = ""
     if empty(a:args)
         let runCmd = expand('%:p:r')
     else
         let runCmd = join(map(split(a:args), 'expand(v:val)'))
     endif

     let main_win_buf = bufwinnr(expand("%:p:t"))

     if !empty(runCmd)
         "echo 'Executing: '.runCmd
         call ExecuteInshellv(runCmd)
     endif
     if main_win_buf > 0
         silent execute main_win_buf . 'wincmd w'
     endif
     echo "Window " .main_win_buf
 endfunction

 nnoremap <leader>c :make<CR>
 nnoremap <leader>r :Run<CR>
